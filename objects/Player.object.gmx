<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayer</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// set tool properties

tool[0,0]=sprPlayerCannon; // set the sprite of a tool
tool[1,0]=sprPlayerDrill;
tool[2,0]=sprPlayerDualgun;
tool[3,0]=sprPlayerLaser;

// set what tools the player has active

activeTool[0,0]=0; // this sets the players first active tool slot to 0 --- this means that the players first active tool slot will contain the tool in the 'tool' array that has the first value of 0
activeTool[0,1]=0; // this sets the active tools rotation

activeTool[1,0]=1;
activeTool[1,1]=1;

activeTool[2,0]=2;
activeTool[2,1]=2;

activeTool[3,0]=3;
activeTool[3,1]=3;

rotation=0; // rotation determines the order of the tools
drawRot=0;

// make sure it doesn't get stuck when spawning
world_carve_circle(x, y, 48, 0);

// prepare legs
for(var i = 0; i &lt; 4; i += 1)
{
    legActive[i] = 0;
    legX[i] = x;
    legY[i] = y;
}

// hitbox
hBoxXOffset = -12;
hBoxYOffset = -12;
hBoxWidth = 23;
hBoxHeight = 23;

// movement
xVel = 0;
yVel = 0;
accel = 0.8;
drag = 1.1;
grav = 0.4;

// lighting
lightColor = make_color_rgb(255/3, 150/3, 50/3);
lightRadius = 128;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i=0;

rotation += keyboard_check_pressed(World.keyRotCCW) - keyboard_check_pressed(World.keyRotCW);
drawRot=lerp(drawRot,rotation,.1);

// move around
var _accel = accel;
var _legsActive = 0;
for(var i = 0; i &lt; 4; i += 1)
{
    if(!legActive[i]) _accel -= accel/6;
    else _legsActive += 1;
}

if(_legsActive)
{
    if(keyboard_check(World.keyUp))
    yVel -= _accel;
    if(keyboard_check(World.keyDown))
    yVel += _accel;
    if(keyboard_check(World.keyLeft))
    xVel -= _accel;
    if(keyboard_check(World.keyRight))
    xVel += _accel;
}

yVel += grav*((4-_legsActive)/4);

// attract to middle points between legs
if(_legsActive)
{
    var _midX = 0;
    var _midY = 0;
    for(var i = 0; i &lt; 4; i += 1)
    {
        if(legActive[i])
        {
            _midX += legX[i];
            _midY += legY[i];
        }
    }
    
    _midX += x;
    _midY += y;
    
    _midX /= _legsActive+1;
    _midY /= _legsActive+1;
    
    xVel += lengthdir_x(_legsActive*0.1, point_direction(x, y, _midX, _midY));
    yVel += lengthdir_y(_legsActive*0.1, point_direction(x, y, _midX, _midY));
}

// check for collisions
var _collided = 0;
for(var i = x+hBoxXOffset; i &lt; x+hBoxXOffset+hBoxWidth; i += 1)
{
    for(var j = y+hBoxYOffset; j &lt; y+hBoxYOffset+hBoxHeight; j += 1)
    {
        if(World.terrain[clamp(i+xVel, 0, World.width-1), clamp(j, 0, World.height-1)] != 0 // air
        || i+xVel &lt; 0
        || i+xVel &gt;= World.width)
        {
            if(xVel &lt; 2)
            xVel *= -0.5;
            else
            {
                xVel *= 0.5;
                _collided += 1;
            }
        }
        if(World.terrain[clamp(i, 0, World.width-1), clamp(j+yVel, 0, World.height-1)] != 0 // air
        || j+yVel &lt; 0
        || j+yVel &gt;= World.height)
        {
            if(yVel &lt; 2)
            yVel *= -0.5;
            else
            {
                yVel *= 0.5;
                _collided += 1;
            }
        }
    }
}

if(_collided)
{
    for(var i = clamp(x-hBoxWidth/2-abs(xVel), 0, World.width-1); i &lt; clamp(x+hBoxWidth/2+abs(xVel), 0, World.width-1); i += 1)
    {
        for(var j = clamp(y-hBoxHeight/2-abs(yVel), 0, World.height-1); j &lt; clamp(y+hBoxHeight/2+abs(yVel), 0, World.height-1); j += 1)
        {
            world_carve_point(i, j);
        }
    }
}

/*var _bumped = 0;
for(var i = clamp(x-hBoxWidth/2+xVel, 0, World.width-1); i &lt; clamp(x+hBoxWidth/2+xVel, 0, World.width-1); i += 1)
{
    for(var j = clamp(y-hBoxHeight/2+yVel, 0, World.height-1); j &lt; clamp(y+hBoxHeight/2+yVel, 0, World.height-1); j += 1)
    {
        if(!_bumped
        &amp;&amp; World.terrain[i, j] != 0 // air
        &amp;&amp; point_distance(i, j, x, y) &lt;= hBoxWidth/2)
        {
            xVel += lengthdir_x(-xVel, point_direction(i, j, x, y));
            yVel += lengthdir_y(-yVel, point_direction(i, j, x, y));
            _bumped = 1;
        }
    }
}*/

x += xVel;
y += yVel;
    
if(_legsActive)
{
    // air drag (aka AERIAL FRICTION)
    xVel /= drag;
    yVel /= drag;
}

// move legs
for(var i = 0; i &lt; 4; i += 1)
{
    var _relocateLeg = 0;
    
    if(!legActive[i]
    //|| point_distance(x, y, legX[i], legY[i]) &gt; 64)
    || point_distance(clamp(x+lengthdir_x(32, i*90+45), 0, World.width-1), clamp(y+lengthdir_y(32, i*90+45), 0, World.height-1), legX[i], legY[i]) &gt; 48)
    {
        _relocateLeg = 1;
    }
    
    if(_relocateLeg)
    {
        legActive[i] = 0;
        var _hooked = 0;
        
        for(var l = 1; l &lt; 48; l += 1)
        {
            var _dToggle = 1;
            
            for(var d = 0; d &lt; 40; d += 1)
            {
                if(World.terrain[clamp(x+lengthdir_x(l, i*90+45+d), 0, World.width-1), clamp(y+lengthdir_y(l, i*90+45+d), 0, World.height-1)] != 0 // air
                || x+lengthdir_x(l, i*90+45) &lt; 0
                || x+lengthdir_x(l, i*90+45) &gt;= World.width
                || y+lengthdir_y(l, i*90+45) &lt; 0
                || y+lengthdir_y(l, i*90+45) &gt;= World.height)
                {
                    _hooked = l;
                    break;
                }
                
                if(_dToggle) d -= 1;
                _dToggle *= -1;
            }
        }
        
        if(_hooked)
        {
            legActive[i] = 1;
            legX[i] = x+lengthdir_x(l, i*90+45);
            legY[i] = y+lengthdir_y(l, i*90+45);
        }
    }
}

for(var i = 0; i &lt; 4; i += 1)
{
    if(World.terrain[clamp(legX[i], 0, World.width-1), clamp(legY[i], 0, World.height-1)] == 0 // dettach legs if not grabbing walls
    || abs(angle_difference(point_direction(x, y, legX[i], legY[i]), i*90+45)) &gt; 40)
    {
        legActive[i] = 0;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// draw tools
var i;

for (i=0;i&lt;=3;i++) {
    draw_sprite_ext(
        tool[activeTool[i,0],0],
        0,
        x+lengthdir_x(12,(activeTool[i,1]+drawRot)*90),
        y+lengthdir_y(12,(activeTool[i,1]+drawRot)*90),
        1,
        1,
        (activeTool[i,1]+drawRot)*90,
        c_white,
        1
    )
}

// draw legs
for(var i = 0; i &lt; 4; i += 1)
{
    if(legActive[i])
    draw_line(x, y, legX[i], legY[i]);
}

// draw tank
draw_self();


// DEBUG
// hitbox
draw_set_color(c_red);
draw_rectangle(x+hBoxXOffset, y+hBoxYOffset, x+hBoxXOffset+hBoxWidth, y+hBoxYOffset+hBoxHeight, 1);
draw_rectangle(x+hBoxXOffset+xVel, y+hBoxYOffset+yVel, x+hBoxXOffset+hBoxWidth+xVel, y+hBoxYOffset+hBoxHeight+yVel, 1);

draw_set_color(c_white);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
