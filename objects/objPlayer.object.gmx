<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprTankHeadpiece</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// initialize variables
hsp = 0;
vsp = 0;
spd = 6;
rot = 0;
frame = 0;
add = 0;
addSign = 0;
scale = 1;
jumpSpd = 24;

// initialize tank treads
//           x, y, length, angle, radius
tread_create(x, y, 88,     0,     16);
repeat(18)
{
    tread_part_add();
    repeat(16)
    {
        treads_move(0.9, 4);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// DEBUG STUFF
if(keyboard_check_pressed(ord('R'))) { game_restart(); }

if(mouse_check_button_pressed(mb_left))
{
    /*with(instance_create(mouse_x, mouse_y, LightSource))
    {
        // color n radius
        color = make_color_hsv(current_time/20, 255, 255);
        depth = other.depth-1;
    }*/
    with(instance_create(mouse_x, mouse_y, ICEDUMMY))
    {
    }
}

// set keys
keyRight = keyboard_check(vk_right);
keyLeft = -keyboard_check(vk_left);
keyJump = keyboard_check_pressed(vk_space);
keyJumpHeld = keyboard_check(vk_space);
keyFire = keyboard_check_pressed(ord('D'));

// horizontal speed
hsp = (keyRight + keyLeft) * spd;

// jumping
if (place_meeting(x,y+1,objWall)) {
    vsp = keyJumpHeld * -(jumpSpd);
} else vsp += 1;

if (vsp &lt; 0) &amp;&amp; (!keyJumpHeld) vsp = max(vsp,0);

// collision
if (place_meeting(x+hsp,y,objWall)) hsp = 0;
if (place_meeting(x,y+vsp,objWall)) vsp = 0;

// add hsp and vsp
x += hsp;
y += vsp;

create_cam(); // create the camera if it doesn't already exist

image_speed = sign(hsp);

if (hsp != 0) add += addSign;

if (add &gt; .5) addSign = -.1;
if (add &lt; -.5) addSign = .1;

if hsp !=  0 rot += sign(hsp) / 16 else rot /= 1.25;

// fire
if(keyFire)
{
    rot = 5*scale;
    with(instance_create(x+80*scale, y-20, Effect))
    {
        sprite_index = sprBarrelSmoke;
        depth = other.depth-1;
        image_xscale = other.scale;
        //image_speed = 0.5;
        
        with(instance_create(x, y, LightSource))
        {
            intensity = 5;
            intensityLinearScale = -1;
            color = make_color_hsv(25, 255, 255);
        }
    }
    with(instance_create(x+80*scale, y-20, TankShell))
    {
        hspeed = 16*other.scale;
        vspeed = -2;
    }
}

rot = clamp(rot,-5,5);

// update tank tread position
/*tread_x = x;
tread_y = y;
treads_move(0);
treads_offset(x-xprevious, y-yprevious);*/
if(keyRight || -keyLeft) repeat(max(1, abs(rot))) treads_move(0.5, 2);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frame += (.2 * abs(sign(hsp))) * (abs(sign(vsp) - 1));
if (sign(hsp) == 1) scale = 1 else if (sign(hsp) == -1) scale = -1; // I'm not just throwing in scale = sign(hsp) because scale can never equal 0, otherwise the sprite will turn invisible

// Draw tank parts

// draw tank tread parts
draw_sprite(sprTankTread, frame, x + (5 * scale), y + (sprite_get_height(sprTankTread) / 1.6));
if(surface_exists(global.surTankTreads))
{
    draw_line(tread_x, tread_y, tread_x+lengthdir_x(tread_l, tread_a), tread_y+lengthdir_y(tread_l, tread_a));
    for(var i = 0; i &lt; tread_parts; i += 1)
    {
        draw_set_color(make_color_hsv((255/tread_parts)*i, 255, 255));
        //draw_line(tread_partX[i], tread_partY[i], tread_partX[i]+lengthdir_x(tread_l, -tread_partAngle[i]), tread_partY[i]+lengthdir_y(tread_l, -tread_partAngle[i]));
        if(tread_partAngle[i] != 0
        &amp;&amp; tread_partAngle[i] != 180)
        {
            draw_sprite(sprTankTreadPart, round(tread_partAngle[i]/(360/sprite_get_number(sprTankTreadPart)))+1, tread_partX[i], tread_partY[i]);
        }
        else
        {
            draw_sprite(sprTankTreadPart, round(tread_partAngle[i]/(360/sprite_get_number(sprTankTreadPart))), tread_partX[i], tread_partY[i]);
        }
    }
    draw_set_color(c_white);
    
    surface_set_target(global.surTankTreads);
    draw_clear_alpha(c_black, 0);
    for(var i = 0; i &lt; tread_parts; i += 1)
    {
        if(tread_partY[i] &gt;= tread_y-tread_r/2)
        {
            //draw_sprite(sprTankTreadPart, round(tread_partAngle[i]/(360/sprite_get_number(sprTankTreadPart))), tread_partX[i]-view_xview, tread_partY[i]-view_yview);
            if(tread_partAngle[i] != 0
            &amp;&amp; tread_partAngle[i] != 180)
            {
                draw_sprite(sprTankTreadPart, round(tread_partAngle[i]/(360/sprite_get_number(sprTankTreadPart)))+1, tread_partX[i], tread_partY[i]-view_yview);
            }
            else
            {
                draw_sprite(sprTankTreadPart, round(tread_partAngle[i]/(360/sprite_get_number(sprTankTreadPart))), tread_partX[i], tread_partY[i]-view_yview);
            }
        }
    }
    surface_reset_target();
    
    draw_surface_ext(global.surTankTreads, x-((view_wview-210)*scale), y-view_hview/2, scale, 1, 0, c_white, 1);
}

draw_sprite_ext(sprTankHeadpiece, frame, x + (10 * scale), y - (sprite_get_height(sprTankHeadpiece) / 1.4) + add, scale, 1, add + rot, c_white, 1);
draw_sprite_ext(sprTankBody, frame, x + add, y, scale, 1, add + rot, c_white, 1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
